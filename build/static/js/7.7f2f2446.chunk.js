(this.webpackJsonpportfolio=this.webpackJsonpportfolio||[]).push([[7],{42:function(e,t,n){"use strict";n.r(t);var i=n(0),a=n.p+"static/media/ftPrintfRequirements.9083de08.jpg",s=n.p+"static/media/ftPrintfUnitTest.90e41c33.jpg",o=n.p+"static/media/ftPrintfUnitTests.508f1c83.jpg",r=n(38),c=n(18),d=n(39),h=n(1);t.default=function(){var e=Object(h.jsxs)("div",{className:"grid gap-6 grid-cols-1 lg:grid-cols-2",children:[Object(h.jsxs)("div",{className:"flex flex-col items-center justify-between",children:[Object(h.jsx)("p",{children:"Ft_printf is a project from 42 school that requires us to create a function that mimics the printf function which is defined in stdio.h header file."}),Object(h.jsx)("p",{children:"As seen on the image, the requirements are quite extensive, the function should be able to handle at least 9 different conversions as well a minimum of 4 flags, which can all be combined into a single function call."}),Object(h.jsx)("p",{children:"Not only that, and as per usual at 42, everything has to work perfectly (which is one of the reasons I love 42), no memory leaks are allowed, and the behaviour must be exactly the same as the original printf except for undefined behaviour."})]}),Object(h.jsx)(c.a,{src:a,alt:"Requirements for project",rounded:!0})]}),t=Object(h.jsxs)(i.Fragment,{children:[Object(h.jsx)("p",{children:"The first thing I did was to understand how width and precision worked by reading and re-reading extensively Microsoft docs."}),Object(h.jsx)("p",{children:"Some tests were done and I started going for it. Only to realise a bit later that this was much more complicated than I had anticipated, especially how width and precision are dependant on each other and vary for each conversion."}),Object(h.jsx)("p",{children:"I went back to testing by running the original printf function with every single combination of flags and conversions I could think of in order to understand the ins and outs of printf, before rethinking my logic again."}),Object(h.jsxs)("div",{className:"grid gap-8 grid-cols-1 px-4 py-4 lg:gap-12 lg:grid-cols-2",children:[Object(h.jsx)(c.a,{src:s,alt:"Command line interface with code written for tests",dynamicClasses:"rounded-lg"}),Object(h.jsx)(c.a,{src:o,alt:"Command line interface with code written for tests",dynamicClasses:"rounded-lg"})]})]}),n=Object(h.jsxs)(i.Fragment,{children:[Object(h.jsx)(d.a,{title:"Dealing with flags interdependencies",content:"This was difficult to deal with because I created a re-usable function that dealt with precision only and another with width. The problem here was that they behaved differently with each other depending on the type of conversion. To solve this I made these 2 functions deal only with getting precision and width values and then each conversion had its own logic to deal with this interdependency.",success:!0}),Object(h.jsx)(d.a,{title:"Negative input and me",content:"Both width and precision have their own rules to deal  with negative numbers as inputs. My solution for this was to add another variable to my struct  in order to keep track if the value is negative, from there  I had to implement different logic on each conversion and  flag based on this bool variable.",success:!0}),Object(h.jsx)(d.a,{title:"Bonus part of the project",content:"As with most projects at 42 you have the mandatory and the bonus parts for each project. For this project I decided the bonus wasn't worth doing,  I understood and solved the problems with many flags and conversions and felt this was enough to learn what I was supposed to with  this project. Doing the bonus part would just make me use the  same helper functions I had already created and adapt the logic for each new conversion or flag."})]});return Object(h.jsx)(r.a,{title:"Ft_printf",overview:e,approach:t,challenges:n,githubPath:"https://github.com/Nuno111/42Lisboa-level1-ft_printf"})}}}]);
//# sourceMappingURL=7.7f2f2446.chunk.js.map